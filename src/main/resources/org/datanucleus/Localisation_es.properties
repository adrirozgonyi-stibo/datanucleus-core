################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
#     ...
#
# Resources for org.datanucleus package (Spanish)
################################################################################
#
# ClassLoader
#
001000=¡La clase {0} no esta en el CLASSPATH!. Por favor compruebe la especificación y el CLASSPATH.
001001=PersistenceManagerFactory tiene ClassLoaderResolver de nombre "{0}" pero el mecanismo de plugin de DataNucleus no lo ha encontrado. Por favor compruebe el CLASSPATH y especificación de plugin.
001002=ClassLoaderResolver plugin con clase "{0}" pero no existe! Por favor compruebe el CLASSPATH y especificación de plugin.
001003=ClassLoaderResolver para la clase "{0}" ha dado error en la creación : {1}
001004=¡La clase {0} no esta en el CLASSPATH! [ClassResolver llamado por {1} (linea {2})]
001005=¡La clase {0} no esta en el CLASSPATH!.
001006=¡La clase "{0}" no esta en el CLASSPATH!. Usted tiene que tener "{1}" en el CLASSPATH!

#
# DatastoreIdentity
#
002001=PersistenceManagerFactory tiene datastore-identity de nombre "{0}" pero el mecanismo de plugin de DataNucleus no lo ha encontrado. Por favor compruebe el CLASSPATH y especificación de plugin.
002002=datastore-identity "{0}" usa clase "{1}" pero la clase no existe! Por favor compruebe el CLASSPATH y especificación de plugin.
002003=El valor del datastore identity no es valido : {0}
002004=Identidad "{0}" puesto a la clase {1}, pero el tipo de object-id no esta correcta.

#
# L1 Cache
#
003001=Cache de nivel 1 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
003002=Cache de nivel 1 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
003003=Cache de nivel 1 del tipo "{0}" inicializada
003004=Objeto con identidad "{0}" añadido a la Cache de nivel 1 (loadedFlags="{1}")
003005=Objeto con identidad "{0}" reemplazado en la Cache de nivel 1 (loadedFlags="{1}")
003006=Intenta añadir a la Cache de nivel 1 un objeto con id nulo. Rechazado.
003007=Objeto con identidad "{0}" no esta en la Cache de nivel 1
003008=Objeto con identidad "{0}" obtenido de la Cache nivel 1 (loadedFlags="{1}")
003009=Objeto con identidad="{0}" borrado de la Cache de nivel 1

003011=Cache de nivel 1 vaciada.
003012=Objeto con identidad "{0}" va a ser cambiado para ser referenciado por id="{1}" en la Cache de nivel 1
#
# L2 Cache
#
004000=Cache de nivel 2 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
004001=Cache de nivel 2 "{0}" esta registrado para usar la clase "{1}" pero no existe o que tiro una excepcion al iniciarlo. Por favor compruebe el CLASSPATH y la especificación de plugin.
004002=Cache de nivel 2 del tipo "{0}" inicializada
004003=Objeto con identidad "{0}" añadido a la Cache de nivel 2 (campos="{1}", version="{2}")
004004=Intenta añadir a la Cache de nivel 2 un objeto con id nulo. Rechazado.
004005=Objeto con id "{0}" no esta en la Cache de nivel 2
004006=Objeto con identidad "{0}" obtenido de la Cache nivel 2 (campos="{1}", version="{2}") - representado como "{3}"
004007=Objeto con identidad "{0}" borrado de la Cache de nivel 2
004009=Cache de nivel 2 vaciada.
004011=Intenta almacenar un valor nulo en la Cache. No es posible.
004014=Objeto con identidad "{0}") borrado de la Cache de nivel 2 porque ha cambiado pero ha sido GCed
004015=Objeto con identidad "{0}" cambiado en la Cache de nivel 2 (campos="{1}", version="{2}") para campos "{3}"
004016=Objeto con identidad="{0}" borrado de la Cache de nivel 2

#
# Enhancer
#
005000=DataNucleus Enhancer (versión {0}) para el API "{1}" utilizando el JRE "{2}"
005001=DataNucleus Enhancer : Classpath
005002=>>  {0}
005003=¡Archivo "{0}" no existe!
005004=DataNucleus Enhancer ha terminado con exito para {0} clases. Tiempos : input={1} ms, enhance={2} ms, total={3} ms. Compruebe el LOG para los detalles
005005=DataNucleus Enhancer ha terminado con exito para {0} clases.
005006=DataNucleus Enhancer ha terminado con un error. Por favor lee el LOG para los detalles. Habia errores con algunas de las clases
005007=DataNucleus Enhancer ha terminado sin enhance ninguna clase. Compruebe el LOG para los detalles.

005008=Ningun archivo "persistence.xml" ha sido encontrado en el CLASSPATH pero entro el nombre ("{0}") de un "persistence-unit". Tiene que tener el archivo "persistence.xml" en el CLASSPATH en una carpeta valida para esta opción.
005009=Ningun "persistence-unit" con nombre "{0}" existe en el CLASSPATH. Por favor compruebe los archivos "persistence.xml" disponible

005010=Enhance de la clase "{0}" empezando ...
005011=Enhance de la clase "{0}" ha terminado

005012=Validación de enhancement de la clase "{0}" empezando ...
005013=Validación de enhancement de la clase "{0}" ha terminado

005014=La clase "{0}" esta enhanced.

005015=Escribiendo el archivo de clase "{0}" con definición enhanced
005016=La clase "{0}" necesita clase de primary-key; creandola con nombre {1}
005017=Escribiendo el archivo de clase de primary-key "{0}"
005018=Hemos encontrado un error durante el enhance de la clase "{0}" : {1}

005019=Agregando el método "{0}"
005020=Agregando el constructor "{0}"
005021=Agregando el campo "{0}"
005022=Agregando el interfaz: {0}

005023=Enhancing método original {0}, cambiando el uso del campo "{1}" para utilizar "{2}"
005024=Enhancing método original {0} : ignorando enhance de {1} del campo "{2}"

005025=Has intentado utilizar el campo "{0}" pero el campo no estaba detachado cuando detacha el objeto. No debes utilizar el campo, o debes detacharlo mientras detacha el objeto.
005026=Has intentado utilizar la propiedad "{0}" pero la propiedad no estaba detachado cuando detacha el objeto. No debes utilizar la propiedad, o debes detacharlo mientras detacha el objeto.

005027=La clase "{0}" no implementa el interfaz "{1}"!
005028=La clase "{0}" no tiene el campo "{1}" pero lo necesita
005029=La clase "{0}" tiene el campo "{1}" pero el acceso esta incorecta
005030=La clase "{0}" tiene el campo "{1}" pero tiene tipo incorecta "{2}" (debe ser "{3}")
005031=La clase "{0}" no tiene el método "{1}" pero lo necesita
005032=La clase "{0}" tiene el método "{1}" pero el acceso esta incorecta

005033=Enhancing el método original "{0}" para llamar a "dnPreSerialize"

005034=No hay bytes de enhanced clase "{0}"
005035=No hay bytes de la clave primaria por la clase "{0}"
005036=ENHANCED (Persistable) : {0}
005037=ENHANCED (Persistence-Aware) : {0}
005038=NOT ENHANCED (Non-Persistent) : {0}
005039=ERROR (Persistable) : {0}
005040=ERROR (Persistence-Aware) : {0}
005041=ERROR (Non-Persistent) : {0}

#
# FetchPlan
#
006000=El campo "{0}" del fetch-group "{1}" no existe en la clase "{2}
006001=Fetch-group "{0}" jerarquizado en el fetch-group "{1}" no existe en la clase "{2}"
006002=El valor {0} no tiene ningun sentido para maxFetchDepth. Usted tiene que poner -1 (no hay limite) o un valor positivo.
006003=No se puede cambiar los raices de detachar antes de commit().
006004=Intenta añadir el campo "{0}" al fetch group de la clase "{1}", pero el campo no existe en la clase!

#
# Reachability
#
007000=Object con id "{0}" y estado de vida "{1}" añadido a la lista de alcanzables al commit.
007001=Haciendo la calculación de alcanzables con objeto con identidad "{0}"
007002=Haciendo la calculación de alcanzables con el contenedor multi-valor del campo "{0}"

007004=Haciendo la calculación de alcanzables en el campo de PC "{0}"
007005=No podremos encontrar el StateManager del objeto de PC "{0}" al campo "{1}" - ignorandolo
007006=El campo "{0}" ha sido seleccionado no usar "cascade-persist". No vamos a persistir este campo.
007007=Objeto con identidad "{0}" campo "{1}" va a ser persistido por "cascade-persist".
007008=Objeto con identidad "{0}" campo "{1}" ha sido seleccionado no usar "cascade-update". No vamos a persistir este campo.
007009=Objeto con identidad "{0}" campo "{1}" va a ser cambiado por "cascade-update".

#
# NucleusContext
#
008000=DataNucleus Context : Versión: "{0}" con JRE "{1}" en "{2}"
008003=No hay ningun adaptador de API "{0}". Usando lo que tenemos ahora mismo
008004=No hay ningun StoreManager del tipo "{0}". Por favor compruebe que usted ha puesto "datanucleus.storeManagerType" correctamente y que todos los plugins necesarios estan en el CLASSPATH
008005=No hay ningun StoreManager para la clave de URL de base de datos "{0}". Por favor compruebe que los plugins existen en el CLASSPATH (datanucleus-rdbms?, datanucleus-db4o?), y piensa de poner la propiedad de persistencia "datanucleus.storeManagerType" al tipo de base de datos que quiere e.g rdbms, db4o

008009=El MetaDataManager para el API "{0}" no esta registrado. Por favor compruebe que el plugin apropiado esta en el CLASSPATH
008010=Error en la creción del MetaDataManager para el API "{0}" : {1}
008011=La propiedad {0} ha sido especificada pero no podemos usarla porque la base de datos es de sólo-lectura
008012=La propiedad "{0}" tiene el valor "{1}" pero el valor no es válido. Por favor consulte la documentación para ver la lista de valores correctos.
008013=El archivo de propiedades "{0}" leemos antes. Vamos a ignorar el archivo de propiedades "{1}"
008014=No se puede leer el archivo de propiedades "{0}"
008015=Propiedad {0} desconocida - vamos a ignorarla
008016=GenerateSchema : no era posible generar el esquema como este base de datos ("{0}") no soporta operaciones del esquema
008017=Compiling NamedQuery {0} : "{1}"

#
# Connections
#
009000=La Connección ha sido reservado por usted y debe cerrarla antes de usar operaciones del API.
009001=La factoría de conexiones ({0}) no está soportada - debe ser un javax.sql.DataSource
009002=La factoría de connexiones "{0}" no existe o no se encuentra disponible
009003=Ya existe una conexión a la base de datos - quizas un Query siga ? La especificación de JDO sección 12.6 dice que un PersistenceManager puede usar solamente una connección a la base de datos en un momento. Si usted quiere hacer otras operaciones, debe usar más PersistenceManagers.

009010=Error en abrir una connexión para datasource "{0}" - compruebe la especificación de datasource y/o driver
009011=ManagedConnection ABIERTO : "{0}" en resource "{1}"
009012=ManagedConnection ABIERTO : "{0}" en resource "{1}" con isolación "{2}" y auto-commit={3}
009013=ManagedConnection CERRADO : "{0}" 
009014=ManagedConnection ya esta cerrado! : "{0}"
009015=ManagedConnection VA A COMMIT : "{0}"
009016=ManagedConnection VA A ROLLBACK : "{0}"
009020=ManagedConnection FALLO A COMMIT : "{0}" para la transacción "{1}" con onePhase="{2}"
009022=ManagedConnection FALLO A ROLLBACK : "{0}" para la transacción "{1}"

#
# ExecutionContext
#
010000=ExecutionContext "{0}" se abrió para la base de datos "{1}" con transacción="{2}"
010001=ExecutionContext "{0}" se cerró
010002=ExecutionContext ya esta cerrado
010003=ExecutionContext.internalFlush() empezado con flush ordenado - {0} objetos registrados
010004=ExecutionContext.internalFlush() terminado
010005=Intento de obtener un objeto nondurable en estado HOLLOW por getObjectById!
010006=No hay ningun objeto nondurable con este identidad en el cache - ¿quizas de otro Manager?
010007=Objeto con id "{0}" es manejado por otro ExecutionContext
010008=Objeto no es detachado. Esta operación le hace falta un objeto en este estado
010009=Haciendo el objeto detachado : "{0}" (profundidad={1})
010010=Detachando una copia del objeto "{0}" (profundidad={1}) como "{2}" - campos-detachados={3}, campos-para-obtener={4}
010011=DetachOnClose : EMPIEZA - haciendo detach con todos los objetos corrientes ...
010012=DetachOnClose : TERMINADO
010013=No es posible detachar el objeto "{0}" (id="{1}") al cometer como ya no existe en la base de datos. Quizas haya una clave ajena que lo ha borrado
010014=No se puede usar detachCopy() fuera de una transacción cuando haya instancias en el estado "transient" alcanzable
010015=Haciendo el objeto persistente : "{0}"
010016=Haciendo el objeto con identidad "{0}" persistente (adjuntar)
010017=Intento de adjuntar objeto con identidad "{0}" a persistencia pero hay otro objeto persistente con la misma identidad para esta transacción!
010018=Haciendo el objeto persistente (adjuntar) : "{0}" - adjuntando para ser "{1}"
010019=Borrando el objeto de persistencia : "{0}"
010020=No fué posible borrar objetos transitorios.
010021=No fué posible borrar objetos transitorios transaccional. Identidad de objeto = {0}
010022=Haciendo el objeto transitorio : "{0}"

010024=No fué posible cambiar el estado de objetos entre sucio transitorio y non-transaccional
010025=No fué posible cambiar el estado de objetos entre transitorio y non-transaccional
010026=Objeto no existe con identidad "{0}"
010027=El objeto con id "{0}" no ha sido encontrado
010028=No fué posible crear una identidad de objeto por una clase que es nulo!
010029=No fué posible crear una identidad de objeto por la clase "{0}" porque el tipo de clave no esta soportada ({1})
010030=Ocurrió un error durante la construcción de una instancia de Id de tipo "{0}" por la clase abstracta "{1}"
010031=Algunos objetos han fallado de commit() debido a problemas de verificación optimista.
010032=Persistence-By-Reachability (commit) : EMPIEZA
010033=El objeto con identidad "{0}" se almacenó con una llamada a makePersistent() pero ya no esta accesible. Vamos a borrar el objeto de la base de datos.
010034=Persistence-By-Reachability (commit) : TERMINADO
010035=Cannot perform operation since ImplementationCreator doesnt exist in the CLASSPATH (put datanucleus-enhancer.jar in the CLASSPATH).
010036=No fué posible desahuciar algunos de los objetos
010037=No fué posible refrescar algunos de los objetos
010038=No fué posible recuperar algunos de los objetos
010039=No fué posible hacer persistente algunos de los objetos
010040=No fué posible borrar algunos de los objetos
010041=No fué posible hacer transitorio algunos de los objetos
010042=No fué posible hacer transaccional algunos de los objetos
010043=No fué posible hacer non-transaccional algunos de los objetos
010044=No fué posible encontrar el objeto con identidad nulo!!
010045=No fué posible encontrar el objeto con identidad "{0}" del tipo "{1}" como es abstrato y usted no quisó la validación
010046=ExecutionContext.internalFlush() empezado con flush optimizado - {0} para borrar, {1} para persistir, {2} para cambiar
010047=Objeto "{0}" ha sido detachado antes de flush sus cambios a la base de datos. Los cambios no van a llegar a la base de datos. Tiene que ser el resultado de un JPA detach() antes que flush(), que es una tonteria, pero lo hiciste señor!

010048=Objeto "{0}" (id="{1}") pasado a '{2}' pero no tiene StateManager! El objeto tiene que estar manejado.

010050=Intento de empezar una transacción optimistica pero StoreManager para este base de datos no soporte optimistic locking! Elige "datanucleus.Optimistic" como falso.

010051=Intento de buscar un objeto persistible con clase "{0}" y llave "{1}"!
010052=Intento de buscar un objeto persistible de tipo "{0}" pero no hay metadata para esa clase; tiene que ser una clase persistible con metadata.
010053=Intento de buscar un objeto persistible con clase "{0}", campos="{1}" y valores="{2}"!

#
# ImplementationCreator
#
011000=Instance implements persistable loaded by "{0}" but target persistable has classloader "{1}".
011001=A new instance of "{0}" was created, but it is not assignable to PersistenceCapble. Perhaps a classloading problem. "{1}" The instance implements "{2}"
011002=Abstract class "{0}" has abstract method "{1}" but this is not defined as a persistent property in MetaData
011003=Interfaz "{0}" tiene método "{1}" pero no existe como propiedad persistente en el MetaData

#
# Managed Relationships
#
013000=Manejar de relaciones : EMPIEZA
013001=Manejar de relaciones : TERMINADO
013002=Manejar de relaciones : El objeto "{0}" tiene campo "{1}" cambiado a "{2}" pero el campo "{3}" de ese objeto ha sido cambiado a "{4}". Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013003=Manejar de relaciones : El objeto "{0}" tiene campo "{1}" cambiado a "{2}" pero el campo "{3}" de ese objeto ha sido cambiado a nulo. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013004=Manejar de relaciones : El objeto "{0}" tiene una relación bidireccional "{1}" que ya tiene valor de "{2}" pero ya ese objeto va a relacionar con "{3}" asi que ponemos nulo en el campo
013005=Manejar de relaciones : El objeto "{0}" tiene una relación bidireccional "{1}" y el objeto "{2}" ha sido cambiado para relacionar con este objeto, asi que cambiando nuestra relación para estar de acuerdo
013006=Manejar de relaciones : El objeto "{0}" tiene una relación bidireccional "{1}" con el campo "{2}" del objeto "{3}" pero ya no estan relacionados. Quitandolo del contenedor
013007=Manejar de relaciones : El objeto "{0}" tiene una relación bidireccional "{1}" con el campo "{2}" del objeto "{3}" y debe estar en el contenedor pero no esta. Añadiendolo
013008=Manejar de relaciones : El objeto "{0}" tiene una relación bidireccional "{1}" y el objeto "{2}" ha sido añadido, pero ese objeto ya este en estado borrado!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013009=Manejar de relaciones : El objeto "{0}" tiene una relación bidireccional "{1}" y el objeto "{2}" ha sido añadido, pero tiene su dueño como "{3}"!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013010=Manejar de relaciones : El objeto "{0}" tiene una relación bidireccional "{1}" y el objeto "{2}" ha sido borrado, pero tiene este objeto como su dueño!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"

#
# SchemaTool
#
014000=DataNucleus SchemaTool : Creación del esquema para clases
014001=DataNucleus SchemaTool : Eliminación del esquema para clases
014002=DataNucleus SchemaTool : Validación del esquema para clases
014003=DataNucleus SchemaTool : Información de la base de datos
014004=DataNucleus SchemaTool : Información del esquema
014005=DataNucleus SchemaTool : Classpath
014006=>>  {0}
014007=No hay input valido (unos ficheros de metadata/class, o el nombre de un "persistence-unit")!
014008=La creación de un PersistenceManagerFactory ha tirado una excepción : {0} - por favor, consulta el log para obtener mas informacion
014009=DataNucleus SchemaTool : Ficheros
014010=>>  {0}
014011=Leyendo {0} ficheros (metadata/class) ...
014012=Hemos acabado de leer {0} ficheros (metadata/class)
014013=Hemos encontrado un error procesando la clase ("{0}"), converiendola a un URL. Por favor, compruebe la especificación y el CLASSPATH
014014=Habia un error leyendo los ficheros. Por favor lee el LOG para obtener mas información. Lo siguiente puede ayudar : {0}
014015=DataNucleus SchemaTool : Usando esquema de persistence-unit "{0}"
014016=No hay archivos "persistence.xml" en el CLASSPATH pero usted ha seleccionado el nombre ("{0}") de "persistence-unit" para SchemaTool. Tiene que ser un archivo "persistence.xml" en el CLASSPATH en una locación valida para usar la opcion.
014017=No hay ningun "persistence-unit" con nombre "{0}" en el CLASSPATH. Por favor compruebe los archivos "persistence.xml" disponible
014018=Enviando Schema DDL a "{0}" para todas las clases
014019=Enviando Schema DDL a "{0}" solo para clases que no tiene esquema
014020=DataNucleus SchemaTool : Propiedades para persistencia
014021=No hemos encontrado metadata!
014022=>>  {0}={1}

014023=DataNucleus SchemaTool : Ayuda\n>> SchemaTool [opciones] [archivos-mapping] [archivos-clase]\ndonde las opciones son\n{0}\n"archivos-mapping" deben estar presentes en el CLASSPATH\n"archivos-clase" deben estar presentes en el CLASSPATH

014024=-createSchema <schemaName> : crear el esquema (si lo soporta la base de datos)
014025=-deleteSchema <schemaName> : borrar el esquema (se lo soporta la base de datos)
014026=-create : Crea las tablas de datos por las clases de los archivos-JDO/clase
014027=-delete : Borra las tablas de datos por las clases de los archivos-JDO/clase
014028=-validate : Valida las tablas de datos por las clases de los archivos-JDO/clase
014029=-dbinfo : Mostrar la información de base de datos (Database version, supported options, jdbc types, etc)
014030=-schemainfo : Mostrar la información de esquema (DDL statements)
014031=-ddlFile <filename> : enviar todo el DDL SQL a un fichero en vez de executarlos en la base de datos
014032=-completeDdl : escribir el DDL en total en vez de solo las partes que falta (con ddlFile)
014033=-help : Escribir este mensaje

014034=DataNucleus SchemaTool : Creación de la base de datos (cat={0}, sch={1})
014035=DataNucleus SchemaTool : Eliminación de la base de datos (cat={0}, sch={1})

014036=DataNucleus SchemaTool : Parametro "mode" solo accepta valores de "create", "delete", "validate", "dbinfo", "schemainfo"
014037=DataNucleus SchemaTool ha lanzado una excepción. Por favor consulte el Log para ver más detalles: {0}
014038=Ocurrió un error al analizar los archivos-JDO !
014039=No hay clases !
014040=No se encuentra la clase {0}! Por favor, compruebe que la clase existe en el CLASSPATH.
014041=No se encuentra el driver de base de datos!
014042=Error : No hay archivos XML de metainformación JDO !
014043=DataNucleus SchemaTool ha terminado con exito
014044=-delete-create : Borra las tablas de datos por las clases de los archivos-JDO/clase y crealas otra vez
014045=DataNucleus SchemaTool : Eliminación y Creación del esquema
014046=Script de base de datos "{0}" no es valido; tiene que ser un archivo, o un URL.

#
# Transactions
#
015000=Transacción empezada para el ExecutionContext {0} (optimistic={1})
015001=Haciendo commit de la transaacción para el ExecutionContext {0}
015002=Haciendo rollback de la transacción para el ExecutionContext {0}
015003=Transacción empezada para la connection {0}
015004=La ransacción no se pudo comenzar
015005=La ransacción no se pudo flush
015006=Haciendo commit de la transacción para la connexión {0}
015007=No se puedo hacer commit de la transacción
015008=Haciendo rollback de la transacción para la connexión {0}
015009=Transaccion ha fallado de restaurar

015012=Nivel de aislamiento no es válido : {0}
015013=La connexión {0} empezó para una transacción pesimista
015014=La connexión {0} terminó para una transacción pesimistac
015015=La connexión {0} empezó para una transacción optimista
015016=La connexión {0} terminó para una transacción optimista
015017=Objeto con identidad "{0}" ha sido puesto en la cache transaccional
015018=Objeto con identidad "{0}" puesto en la cache transaccional ya esta referenciado por id="{1}"
015019=Objeto con identidad "{0}" fue borrado de la cache transactional
015020=Transacción es "rollback-only", asi que no se puede hacer commit en este estado.
015021=No se pudo obtener una connexión.
015022=Transacción committed en {0} ms
015023=Transacción rolled back en {0} ms
015024=El uso de transacciones de JTA necesita una datasource manejado como tiene dependencia al TransactionManager para cometer las connecciones.
015025=Ya hemos asynchronisado con la transacción de JTA, pero hemos recibido otro pedido hacerlo!
015026=Transacción de JTA pero hemos recibido un error buscando la transacción de JTA.
015027=Transacción de JTA esta marcado por rollback, quizas un timeout. Cualquier otra operación que necesita accesso a la base de datos va a fallar.
015028=Error intentando obtener el estado de la transacción de JTA!
015029=Transacción de JTA es necesario para synchronisar con el TransactionManager de JTA, pero no era posible encontrar el NamingService. Por favor compruebe su configuración
015030=Transacción de JTA es necesario para synchronisar con el TransactionManager de JTA, pero no era posible encontrarlo (solo soportamos WebLogic y JBoss)
015031=Una transacción de la base de datos ha sido restaurada, pero se lanzaron las siguientes excepciones durante la transición del estado de los objetos de JDO
015032=La transacción ya está activo.
015033=La transacción ya está activo.
015034=La transacción está activo todavia. Debe cerrar las transacciones usando los métodos commit() o rollback().
015035=La transacción no está activo. Tiene que poner este en una transacción o usar su PersistenceManagerFactory con 'NontransactionalRead' y 'NontransactionalWrite' como 'true'
015036=Se está haciendo commit o rollback de la transacción. Esta operación no esta disponible en este momento.
015037=Una transacción de base de datos ha sido acometida, pero se lanzaron las siguientes excepciones durante la transición del estado de los objetos de JDO
015038=Operation {0} failed on resource: {1}, error code {2} and transaction {3} : {4}
015039=Running {0} operation on resource: {1}, error code {2} and transaction {3}
015040=La transacción no está activo. Tiene que poner este en una transacción.
015041=Imposible performar la operacion como se hace falta una transaccion activa o 'NontransactionalRead' puesto. Usted no tiene ninguna de los dos.
015042=Imposible performar la operacion como se hace falta una transaccion activa o 'NontransactionalWrite' puesto. Usted no tiene ninguna de los dos.
015043=Este base de datos no soporte el nivel de isolacion de transacciones "{0}"
015044=Exception flushing work in JTA transaction. Mark for rollback. Look at the nested exception for details
015045=Cannot mark transaction for rollback after exception in beforeCompletion. PersistenceManager/EntityManager might be in inconsistent state
015046=Exception during afterCompletion in JTA transaction. PersistenceManager/EntityManager might be in inconsistent state
015047=Received unexpected transaction status "{0}"
015048=Transaction.afterCompletion called on {0} but is already closed. This is likely because you're using a JavaEE container like JBoss that has closed the EntityManager before calling afterCompletion on the transaction of that EntityManager - go figure. Any statistics gathering is rendered incorrect as a result.

#
# Types
#
016001=Tipo de Java {0} como el tipo de Java {1}
016002=Excepcion tirada en la conversion de "{0}" a un objeto del tipo "{1}"
016003=Tipos de Java inicializando ...
016004=La clase de mapping "{0}" no existe o no es encuentra. Por favor, compruebe la especificación de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
016005=La clase de SCO "wrapper" "{0}" no existe o no es encuentra. Por favor, compruebe la especificación de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
016006=Soporte para tipos de Java listo : tipos soportados = {0}
016007=Inicializando TypeConverters ...
016008=TypeConverters listo
016009=Clase de contenedor "{0}" no existe. Debe estar en el CLASSPATH.

#
# Sequence
#
017000=No hemos encontrado la secuencia "{0}". Por favor compruebe que existe en un archivo de Meta-Data.
017001=No hemos encontrado el factory-class "{0}" por la secuencia "{1}". Está en el CLASSPATH ?
017002=Ocurrió un error durante la invocacion de método newInstance() en el factory-class "{0}" : {1}
017003=La secuencia "{0}" ya existe y usa el generador "{1}"
017004=La secuencia "{0}" no tiene valores asignados. Por favor llame primero a "allocate(int)" para asignar los valores.
017005=La secuencia "{0}" no genera valores numéricos. Por favor llame a "next()" para obtener el valor como un Objeto.
017006=Error durante el proceso obtener la conexión por la generación de valor : {0}
017007=Error durante el proceso cerrar la conexión por la generación de valor : {0}
#
# Exceptions
#
018000=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data/Annotaciones de la clase no existe o no se encuentra disponible.
018001=No hemos encontrado el Meta-Data/annotaciones para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML correcto y válido.
018002=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data de la clase no existe o no se encuentra disponible.
018003=No hemos encontrado el Meta-Data para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML para JDO correcto y válido.
018004=La clase "{0}" no es Detachable. Este significa que el MetaData de la clase no incluyo el atributo "detachable" como "true".
018005=Algunos de los objetos no son de clases que son Detachable. Este significa que el MetaData de las clases no incluyo el atributo "detachable" como "true". Las excepciones adjuntas tienen los detalles de los objetos.
018006=El objeto de tipo "{0}" esta detachado. ¡No se puede utilizar objetos detachados con esta operación!
018007=La clase persistente no tiene un Extent (definido en el Meta-Data) : {0}
018008=El campo "{0}" contiene un objeto que no esta persistente pero el campo no permite persistencia por cascada.
018009=El campo "{0}" no existe en {1} o no es persistente
018010=El campo #{0} no existe en {1} o no es persistente
019000=La clase {0} ha sido definido con el object-id class {1} que es "inner" pero no es estatica. El ObjectId class debe ser estatica si es "inner".
#
# Primary Key
#
019001=La clase "{0}" ha sido definido con el object-id class {1} que no es publico. El ObjectId class debe ser publico.
019002=La clase "{0}" ha sido definido con el object-id class {1} que no es Serializable. El ObjectId class debe ser Serializable.
019003=La clase "{0}" que utiliza la clase de identidad de JDO SingleFieldIdentity, pero hay mas que un campo con primary-key para la clase. Se puede elegir solo un campo como primary-key
019004=La clase "{0}" ha sido definido con el object-id class {1} que no tiene constructor defecto. Todos los objectId classes deben tener un constructor defecto.
019005=La clase "{0}" ha sido definido con el object-id class {1} que no tiene un constructor de String. Todos los objectId classes deben tener un constructor de String.
019006=La clase "{0}" ha sido definido con el object-id class {1} que no define el método toString(). Todos los objectId classes deben definir el método toString().
019007=La clase "{0}" ha sido definido con el object-id class {1} que no define el método hashCode(). Todos los objectId classes deben definir el método hashCode() para utilizar todos los campos de la clave primaria.
019008=La clase "{0}" ha sido definido con el object-id class {1} que no define el método equals(). Todos los objectId classes deben definir el método equals() para utilizar todos los campos de la clave primaria.
019009=La clase "{0}" ha sido definido con el object-id class {1} que tiene el campo {2} que no es Serializable. Todos los campos non-estaticos del objectId class deben ser Serializable.
019010=La clase "{0}" ha sido definido con el object-id class {1} que tiene un campo {2} que no es publico. Todos los campos non-estaticos de un objectId class deben ser publico.
019011=La clase "{0}" utiliza la clase de identidad {1} que tiene un campo {2}, pero el campo no existe en la clase {0}.
019012=La clase "{0}" ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} que es persistence-capable. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
019013=La clase "{0}" ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} pero debe ser {4}. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
019014=La clase "{0}" ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {1}.{2} tiene un tipo {3} que debe estar en /jdo/package/class/@objectid-class attributo para tipo {4}. e.g <class name="{4}" objectid-class="{3}"/>
019015=La clase "{0}" ha sido definido con el object-id class {1} que tiene {2} campos, mientras la clase ha sido definido con {3} campos en el "primary-key". El numero de campos en el objectidClass y el numero en el "primary-key" deben ser lo mismo.
019016=La clase "{0}" tiene una clave primaria {1} que esta invalido.

#
# Query
#
021000=Tipo de parámetro incompatible : era {0}, pero debe ser {1} o una subclase
021001=El Query de JDOQL ha vuelto más que una instancia pero "unica" esta "verdad" o hay solo aggregados asi que debe devolver una como maxima.
021002=La declaración del import no es valido : {0}
021003=La declaración del package import no es valido : {0}
021004=La declaración del class import es duplicado : {0}
021005=La clase de los imports no existe : {0}
021006=Almacenando el hecho de que {0} no fuera encontrado por {1}
021007=Los tipos de Array son illegal : {0}
021008=Hay ambiguedad en la declaración de la clase ; puede ser {0} o {1}
021009=La clase de candidato "{0}" no existe!
021010=La clase {0} ha sido resuelto a {1}. Usted no la puso completamente en el Query y por eso podria evitar en look-up (y mejorar el rendimiento) si la ponga con nombre de paquete etc.
021011=Intento de invocar el método "{0}()" del objeto de tipo "{1}" - no lo soportamos con este base de datos
021012={1} Query : Procesando la clausula "{0}" con evaluacion en memoria (clausula = "{2}")
021013=El Manager del Query esta cerrado!
021014=Esta Query no se puede cambiar. No puede cambiar su estructura.
021015=Query contiene nombre de una clase "{0}" (clase de candidato, clase de resultado, parametro, o variable) pero no esta resuelto. Por favor, compruebe el nombre y los imports.
021016=Query contiene acceso de "{0}" pero este campo/propiedad no existe!
021017=Query no tiene un Manager
021018=La ejecución del query "{0}" no ha completado antes que el timeout de {1}ms
021019=El query "{0}" empiece en un su propio hilo con el timeout de {1}ms
021020=El query "{0}" ha sido cancelado
021021=Un error ha ocurrido durante la ejecución del query "{0}"
021022=El query "{0}" empiece en un su propio hilo sin timeout
021023=Evaluación del filtro para candidado="{0}" da éxito
021024=Evaluación ha encontrado el variable="{0}" sin valor, y debe tener un valor del "{1}"
021025=Evaluación para variable="{0}" con valor de "{1}"
021026=Evaluación ha procesado todos los valores para el variable¡"{0}" y quita su valor.
021027=Query tiene que borrar objetos, pero hay un orden. No se puede poner el orden si es para borrar instancias.
021028=Query tiene que borrar objetos, pero hay un grupo. No se puede poner el grupo si es para borrar instancias.
021029=Query tiene que borrar objetos, pero el resultado existe. No se puede poner el resultado si es para borrar instancias.
021030=Query tiene que borrar objetos, pero la clase de resultado existe. No se puede poner la clase de resultado si es para borrar instancias.
021031=Query tiene que borrar objetos, pero tiene alcance de resultado. No se puede poner el alcance de resultado si es para borrar instancias.
021032=Query tiene "unique", pero el resultado contiene más que un objeto. No se puede poner "unique" si hay más que un objeto por ser borrado.

021034=No soportamos los query del lenguaje "{0}" para la base de datos "{1}"

021038=Esta implementación de JDOQL no da soporte a bulk update
021039=Esta implementación de JDOQL no da soporte a bulk delete
021040=Esta implementación de JPQL no da soporte a bulk update
021041=Esta implementación de JPQL no da soporte a bulk delete
021042=Ha tirado una excepción en la ejecucion del query : {0}
021043=Error con la extracción de resultados por el Query "{0}"

021044=Query de {0} : Compilación (generic) de "{1}"
021045=Query de {0} : Tiempo de compilar (generic) = {1} ms
021046=Query de {0} : Ejecucion de "{1}" ...
021047=Error en la ejecucion de Query de {0} - "{1}" : {2}.
021048=No hay una clase de candidato por el Query de {0}
021049=No era posible encontrar el campo "{0}" en la clase de candidato. Es posible que este campo es un campo en una subclase, pero es illegal usar campos de las subclases directamente.
021050=El filtro de Query "{1}" no da un resultado de boolean

021053=La clase "{0}" en una expresión (cast) no existe. Por favor compruebe que la clase esta en el CLASSPATH y esta en los imports del Query.

021054=El Query de {0} contiene una expresión invalida
021055=Query tiene algunas parametros declarados ("{0}"), pero hay por lo menos un parametro implicito ("{1}"). Es invalido. Usted debe declarar todos los parametros (explicito), o usar todos los parametros con un prefix :.
021056=Query tiene un parámetro implicito "{0}" (en posición {1}) ¡pero no había un valor disponible para esta posición!

021057=El uso de "new" en {0} debe seguir con el nombre de la clase, pero {1} no existe. Por favor, compruebe la lista de "imports".
021058=El uso de "new" en {0} debe seguir con el nombre de la clase y los argumentos del constructor pero esta incorrecta en "{1}".

021049=No era posible encontrar el campo "{0}" en la clase de candidato. Es posible que este campo es un campo en una subclase, pero es illegal usar campos de las subclases directamente.
021060=Error conectando el variable "{0}" a "{1}" como estaba conectado a "{2}" antes.
021061=El variable "{0}" no esta conectado al Query de JDOQL.

021064=The range {0} expression accepts only Literal values. Either define it as parameter or a literal. The current value is {1}.
021065=The range {0} expression expects a number, but it currently is {1}.
021066=No era posible encontrar la clase "{0}". Por favor, compruebe que la clase existe en el CLASSPATH.
021068=El parametro de Query ("{0}") esta conectado a otro Manager. Es imposible usar este Query asi.
021069=El "ORDER BY" tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el "ORDER BY" tiene que estar tambien en el "GROUP BY".
021070=El resultado tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el resultado tiene que estar tambien en el "GROUP BY".
021071=El "HAVING" tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el "HAVING" tiene que estar tambien en el "GROUP BY".
021051=La expresión de "HAVING" "{0}" no es valido. Debe ser una expresión Boolean.
021072=Collección de candidatos esta vacia!
021074=Query de {0} : Tiempo de ejecutar = {1} ms
021075=Na cacheamos la compilación de la base de datos como necesitamos los valores de algunos parametros para compilarlo

021079=Query "{0}" de lenguaje "{1}" existe, por eso utilizamos la compilacion general de antes.
021080=Query "{0}" de lenguaje "{1}" para la base de datos "{2}" existe, por eso utilizamos la compilacion de datastore de antes
021081=Query "{0}" tiene {1} resultados. Vamos a ponerlos en el cache.
021082=Query "{0}" existe en el cache de resultados de query con {1} resultados. Vamos a utilizarlos

021083=Query de {0} : Compilación (base de datos) de "{1}"
021084=Query de {0} : Tiempo de compilar (base de datos) = {1}

021086=JDOQL query tiene clausula de resultado "{0}" pero es invalido (JDO spec 14.6.10). Cuando lo pone con grouping, debe ser aggregate, o expresion de grouping.
021087=JDOQL query tiene clausula de ordering "{0}" pero es invalido (JDO spec 14.6.10). Cuando lo pone con grouping, debe ser aggregate, o expresion de grouping.
021088=JDOQL query tiene clausula de having "{0}" pero es invalido (JDO spec 14.6.10). Debe ser aggregate, o expresion de grouping.
021089=JDOQL query tiene clausula de result con aggregate ("{0}") pero se hace falta un argumento

# Query : Parameters/Variables
021101=Query tiene una lista de parametros que esta incorrecta "{0}"
021102=Query tiene un parametro "{0}" que esta incorrecta
021103=Query tiene dos o mas parametros con nombre "{0}"
021104=Query tiene una lista de variables que esta incorrecta "{0}"
021105=Query tiene un variable "{0}" que esta incorrecta
021106=Query tiene un variable "{0}" que es lo mismo que un parametro
021107=Query tiene dos o mas variables con nombre "{0}"
021108=Query hace falta {0} parametros, pero tiene {1}.
021109=The parameter {0} expected the argument value of primitive type {1}.
021110=El Query de {0} hace falta un parametro "{1}" pero no esta
021111=Query tiene algunas variables declarados ("{0}"), pero hay por lo menos un variable implicito ("{1}"). Es invalido. Usted debe declarar todos los variables explicito, o usar todos los variables como implicito.
021112=Query contiene un parametro "{0}" pero no hay ningun valor especificado al ejecutar el Query!
021113=Query tiene un valor por el parametro "{0}" pero este parametro no existe en el Query!
021114=Query tiene parametro "{0}" como un {1} pero esta comparado con un {2}. Los valores de parametros deben ser consistente con lo que se compare.
021115=Query tiene un subquery pero no hay declaracion de variables! Un subquery tiene que pasar su valor al Query principal por un variable
021116=Query tiene el parametro "{0}" provisto al ejecucion pero este query no lo utiliza!
021117=Query tiene el parametro "{0}" definido como "{1}" pero el valor es nulo!
021119=Query tiene el parametro "{0}" definido pero usted no ha entrado un valor en el método execute()

# Query : Result
021201=El Query va a volver con mas que un campo pero la clase de resultado es de un tipo simple ({0}). Son inconsistentes.
021202=El Query va a volver con un campo pero no es de la clase de resultado ({0}) : es {1}
021203=El Query tenia que devolver objetos de tipo "{0}" pero era imposible. Por favor compruebe que esta clase esta corecta por el API.
021204=El Query tenia que devolver objetos de tipo "{0}" pero era imposible poner el valor al campo "{1}"  tipo "{2}". El campo debe tener un método publico set/put o ser publico.
021205=El Query tenia que devolver objetos de tipo "{0}" pero era imposible crear nueva instancia de este tipo! La clase de resultado necesita un constructor sin argumentos.
021206=La clase de resultado "{0}" no tiene un constructor con arguments de tipos {1}
021207=La clase de resultado "{0}" no tiene un método publico "void {1}({2})".
021208=La clase de resultado"{0}" no tiene un método publico "void {1}(Object, Object)".
021209=La clase de resultado "{0}" no tiene un campo publico "{1}"

# Query Cache
021500=Cache de Query "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
021501=Cache de Query "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
021502=Cache de Query del tipo "{0}" inicializada

#
# Api Adapter
#
022000=Error : Un error ocurrio cuando creando un adaptador "{0}" (quizas no tengas el jar apropiado datanucleus-api-XXX en el CLASSPATH, o el API jar para la especificacion que utilizas?) : {1}
022001=Error : No se puede encontrar el API {0}. Quizas no tengas el jar apropiado datanucleus-api-XXX en el CLASSPATH?

#
# SCO
#
023000=El tipo de parámetro solicitado por el campo "{0}" : era {1} pero debe ser {2}
023001=El campo {0} no puede ser nulo en objeto "{1}"
023002=El contenedor (Collection/Map) no es preguntable como no tiene dueño que es un objeto de primera clase
023003=Creado SCO wrapper de tipo {0} por objeto "{1}" campo "{2}" con {3} valores, con las opciones="{4}"
023004=El objeto "{0}" campo "{1}" ha sido reemplazado por un SCO wrapper de tipo "{2}" {3}
023005=El objeto "{0}" campo "{1}" enviando cambios del contenedor de SCO a la base de datos
023006=El objeto "{0}" campo "{1}" obteniendo los contenidos al contenedor de SCO de la base de datos
023007=El objeto "{0}" campo "{1}" va a ser inicializado por un contenedor con {2} valores
023008=El objeto "{0}" campo "{1}" va a ser cambiado por un conteneder con {2} valores
023009=Es imposible persistir el objeto "{0}" como esta manejado por otro persistence manager
# needs updating
023011=La clase {0} no tiene soporte como objeto de clase segundo (SCO)
023012=El campo "{0}" debe usar un comparator de clase "{1}" pero esa clase no existe en el CLASSPATH. Por favor compruebe el nombre de la clase de comparator.
023013=Execución del método "{0}" en el campo "{1}" ha causado un error : {2}
#
# Plugin
#
024000=El archivo {0} no existe. Compruebe que esta en el CLASSPATH
024001=Error leer al archivo de plug-in {0} : {1}
024002=Extension Point "{0}" no esta registrado, pero el plugin "{1}" definido en {2} se lo refiere.
024003=Leyendo extension-points y extensiones del archivo de plug-in {0}.
024005=Plugin Registry "{0}" no existe. Usando registry de DataNucleus

024007=Error en la registración del Bundle como el URL al MANIFEST.MF es nulo
024008=Error en leer el manifest "{0}"
024009=El plugin (Bundle) "{0}" ya esta registrado. Por favor compruebe que usted no tiene otras versiones del mismo plugin en el CLASSPATH. El URL "{1}" esta registrado, y intenta registra otro al URL "{2}."
024010=Error en la creación del URL para el plugin MANIFEST "{0}"
024011=Error en leer el MANIFEST.MF for "{0}"
024012=No se puede encontrar el fichero MANIFEST.MF para el plugin "{0}". Vamos a ignorarlo
024013=Bundle "{0}" tiene una dependencia opcional a "{1}" pero no se puede resolverla
024014=Bundle "{0}" se hace falta "{1}" pero no se puede resolverla
024015=Bundle "{0}" se hace falta "{1}" versión "{2}" pero ese bundle tiene versión "{3}" que esta fuera de los versiones aceptadas.
024016=Error en la creacion del DocumentBuilder : {0}
#
# CallbackHandler
#
025000=Error : Un error ocurrio cuando creando un CallbackHandler "{0}" : {1}
025001=Una excepcion ha sido tirado por el callback del usuario "{0}".
#
# StateManager
#
026000=No hay bastante acceso a org.datanucleus.*
026001=Desconectando del clono {0} de {1}
026002=El campo {0} de la clase {1} no existe
026003=Cambiar el StateManager da un error
026004=Desconectar el StateManager da un error
026005=Vaciando el StateManager de {0}
026006=Este método de StateManager no debe ser llamado. Por favor, avisalo al equipo de DataNucleus como reproducirlo
026007=No es posible compartir SCO's con dueños; objeto doñado por campo {0} del objeto {1}
026008=Recurrente llamada a deletePersistent()
026009=Recurrente llamada a flush()
026010=Objeto tiene el estado ´sucio´´ pero ¡no hay campos sucios!
026011=Disconectando objeto con identidad "{0}" de {1}
026012=No puede persistir la clase {0}
026013=Objeto no existe (identidad="{0}")
026014=La clase "{0}" del objeto con id "{0}" na ha sido encontrado
026015=La clase {0} no esta ! Por favor, comprueba usted que la clase existe en el CLASSPATH.
026016=The primary-key field {0} is null.
026017=Un objeto de la clase "{0}" usa SingleFieldIdentity con el campo "{1}" pero el campo no tiene ningun valor! Usted debe poner un valor, o usa "value-strategy" con este campo.
026018=La clase "{0}" no ha sido registrada. Por favor compruebe que esta analizada.
026019=No podemos crear una instancia de la clase "{0}". Si es "abstract", usted tiene que comprobar que no hay una fila por esa clase en la base de datos sin una fila en la tabla de una subclase.
026020=El campo "{0}" tiene value-strategy de "{1}" pero el tipo del campo no esta correcta usarlo.
026021=El campo "{0}" del objeto "{1}" ha sido registrado para actualización cuando su valor PC ("{2}") esta en la base de datos.
026022=Vamos a actualizar el valor del campo "{0}" del objeto "{1}" como su valor PC ("{2}") ya esta en la base de datos.
026023=No podemos "detach" al objeto de tipo "{0}" y con identidad "{1}" porque ha sido borrado!
026024=No podemos "detach" el objeto de tipo "{0}" y con identidad "{1}" porque ya es "detached"!
026025=El "detach" del objeto de tipo "{0}" y con identidad "{1}" ha fallado. Por favor, compruebe el Log para alguna detalle.
026026=Vamos a borrar el objeto "{0}" porque esta el valor en un campo ({1}) donde el valor has sido anulado y el campo es delete-dependent.
026027=Una transition ilegal "{0}" ha sido intentado desde el estado "{1}", sm = "{2}"
026028=El objeto "{0}" ha sido marcado para persistir pero vamos a persistir a la base de datos mas tarde debido a transacción optimistic o "datanucleus.flush.mode" propiedad
026029=El objeto con identidad "{0}" va a tener el valor en el campo "{1}" cambiado por un SCO wrapper
026030=El objeto con identidad "{0}" va a tener el SCO wrapper en el campo "{1}" cambiado por el valor
026031=El objeto con identidad "{0}" va a ser detachado (con la opcion DetachAllOnCommit?) pero no es detachable, por eso vamos a hacerlo transient
026032=El objeto con identidad "{0}" tiene una valor cargado en campo {1} que esta fuera del FetchPlan. Descargandolo.
026033=El objeto con identidad "{0}" va a tener los campos siguientes almacendados en el objeto de Level 2 cache : {1}
026034=El objeto con identidad "{0}" va a tener los campos siguientes cargados del objeto de Level 2 cache : {1}

026035=Attach del objeto con identidad "{0}" campos="{1}"
026036=Una excepcion ha sido tirado durante el attach del objeto con identidad "{0}" : {1}

026037=Almacenando valor de FK para el campo "{0}" de "{1}" a STORED-VALUE-CACHE
026038=Poniendo valor al campo "{0}" de "{1}" del STORED-VALUE-CACHE

#
# LifeCycle states
#
027000=No se puede leer los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalRead=true'.
027001=No se puede escribir los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalWrite=true'.
027002=No se puede leer los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalRead=true'.
027003=No es posible cambiar el estado del objeto a nontransaccional como es nuevo, borrado y no esta comitido
027004=No es posible cambiar el estado del objeto a transitorio como es nuevo, borrado y no esta comitido
027005=No es posible leer campos de un objeto borrado
027006=No es posible escribir campos de un objeto borrado
027007=No es posible cambiar el estado del objeto a nontransaccional como esta borrado
027008=No es posible cambiar el estado del objeto a transitorio como esta borrado
027009=No es posible leer campos de un objeto borrado
027010=No es posible escribir campos de un objeto borrado
027011=No es posible cambiar el estado del objeto a nontransaccional como es sucio
027012=No es posible cambiar el estado del objeto a transitorio como es sucio
027013=No es posible cambiar el estado del objeto a nontransaccional como no es nuevo y no esta comitido
027014=No es posible cambiar el estado del objeto a transitorio como es nuevo y no esta comitido
027015=El campo no esta copiado al objeto "detached". Usted tiene que añadirlo al FetchPlan y "detach" el objeto otra vez.
027016=Objeto con identidad "{0}" tiene cambio de lifeycle : "{1}"->"{2}"
#
# XML Parser
#
028000=XML Entity Public="{0}" System="{1}" : con source local "{2}"
028001=XML Entity Public="{0}" System="{1}
028002=resolveEntity({0}, {1}) no existe
028003=resolveEntity({0}, {1}) ha fallado!
#
# SingleFieldIdentity
#
029000=No era posible construir una identidad de SingleFieldIdentity de tipo "{0}" porque la clase dado es nulo
029001=El tipo de identidad para construir una identidad de SingleFieldIdentity para la clase "{0}" es nulo
029002=El tipo de identidad ("{0}") dado para construir una identidad de SingleFieldIdentity para la clase "{1}" no es valido.
029003=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" para la clase "{1}" es nulo.
029004=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" de la clase "{1}" es de un tipo invalido ("{2}") - debe ser "{3}".

#
# Utils
#
030003=El formato de Timestamp no esta mal: "{0}" - debe ser yyyy-mm-dd hh:mm:ss.fffffffff
030004=Un constructor de la clase {0} no existe, parametros {1} 
030005=Error cuando intentando usar la clase {0}
030006=Error intentando crear un objeto de la clase {0}
030007=Excepcion tirado por constructor por {0}, {1}

#
# RDBMS Views/Macros
#
031000=Incomparable puntales para el macro de interrogacion: {0}
031001=Incomparable punto de interrogacion para el macro de parametro: {0}
031002=No puede parsar macro de identificacion: {0}
031003=Hay una dependencia circular entre las visiones

#
# Store Manager
#
032001=Va a manjejar la persistencia de {0}
032002=Desmanejando la persistencia de todas las clases
032003=Manejando la persistencia de {0} porque era manejado antes

032004=Intenta de poner/cambiar/borrar objeto "{0}" en una base de datos que es para leer. Usted ha puesto esta base de datos "read-only" con la propiedad de persistencia "org.datanucleus.readOnlyDatastore". Debe quitar esta propiedad si quiere poner objetos alli.
032005=Intenta de poner/cambiar/borrar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.
032006=Intenta de poner/cambiar/borrar objeto "{0}" para una clase que es para leer. Usted ha puesto esta clase "read-only"
032007=Intenta de poner/cambiar/borrar objeto "{0}" para una clase que es para leer. Vamos a ignorarlo.

032010=Intenta de borrar objeto "{0}" dependiente de objeto en una base de datos que es para leer
032011=Intenta de borrar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.

032012=La clase "{0}" es "embedded-only" asi que no tiene su propia tabla.
032013=La clase "{0}" usa la estrategia "subclass-table" y no hay una subclase o superclase que tiene una tabla.
032014=La clase "{0}" usa la estrategia {1} y no hemos encontrado una tabla para persistirla.
032015=Intenta obtener el nombre de la tabla de base de datos por una clase nula !

032013=La clase {0} usa estrategia de "subclass-table" pero ningun subclase tiene una tabla definida.

032016=Objeto con identidad "{0}" ha sido cambiado en la base de datos después de la ultima leer. Base de datos tiene version "{1}" pero la transacción tiene version "{2}"
032017=La clase "{0}" tiene estrategia de versiones de "{1}" pero JPA no la soporta ahora mismo. Por favor compruebe la documentación para las estrategias que soportamos.

032018=Registrado la factoria de connecciones transaccionales bajo el nombre "{0}"
032019=Registrado la factoria de connecciones nontransaccionales bajo el nombre "{0}"

032020=StoreManager : "{0}" con el URL "{1}" - datastore-mode={2}

#
# Extent
#
033000=No se puede crear el Extent porque tiene que dar el nombre de la clase.
033001=No se puede crear el Extent de la clase "{0}" porque no hay Meta-Data disponible para esa clase.
033002=El Extent de {0} incluso los subclases={1}
033003=Query sobre Extent nunca va a dar resultado sin subclases : extent= {0}, clase={1}

#
# Auto Starter
#
034000=Error en la inicialisación de DataNucleus : Una clase "{0}" estaba en la lista de persistencia de este esquema pero no la existe. Quizas es de otra aplicación de DataNucleus usando la misma esquema, o has cambiado los nombres de las clases.
034001=Borrando la clase {0} de la lista de clases manejadas
034002=Unknown Error during auto starter execution. : {0}
034003=Illegal state of AutoStart, disabling it. To enable it, resolve earlier errors.
034004=Error en la inicialisación de DataNucleus: una clase "{0}" estaba en la lista de persistencia de este esquema pero ya no tiene MetaData disponible.
034005=AutoStart Mechanism "{0}" empezando
034006=AutoStart Mechanism "{0}" terminado

034100=Mecanismo de AutoStart con clases. Tiene que poner una lista de clases en la construcción del PMF.
034150=Mecanismo de AutoStart con MetaData. Tiene que poner una lista de archivos de MetaData en la construcción del PMF.

034200=Mecanismo de AutoStart de XML. Almacena su definición en un fichero de XML
034201=El fichero de XML AutoStarter {0} no existe. Creandolo ...
034202=Error leer el fichero de XML AutoStart {0} : {1}
034203=Error escribir el fichero de XML AutoStart {0} : {1}
034204=resolveEntity({0}, {1})

#
# Store Data
#
035001=La tabla no puede ser nulo
035002=Clase : {0}
035003=Campo : {0}
035004=Clase : {0} [Tabla : {1}, Estrategia de heredar : {2}]
035005=Campo : {0} [Tabla : {1}]

#
# JDOQL Expressions
#
037003=Query tiene comparacion a un objeto "{0}" que no tiene identidad de JDO - quizas el objeto sea transient o embedded. Siempre devuelve nada.

037005=Query tiene una referencia al campo "{0}" pero la clase usa "subclass-table" estrategia de heredar y no hay ninguna subclase de esa clase. No podemos crear un Query de JDOQL.
037006=Query tiene una referencia al campo "{0}" per la clase usa "subclass-table" estrategia de heredar. DataNucleus soporta una relación 1-1 con "subclass-table" si hay una subclase sola, pero aqui hay mas! Vamos a usar "{1}"

037013=Query de JDOQL tiene una expresión para construir un objeto de la clase "{0}" con un constructor que no existe! Por favor, corrigelo.

037015=Error en la creación de un objeto nuevo de "{0}" : {1}
037016=Query tiene instanceof de "{0}" que es una clase desconocida
037017=Query tiene cast de "{0}" que es una clase desconocida

#
# Value Generators
#
040000=Era imposible crear un generador de identidades de tipo "{0}" : {1}
040001=Creando instancia de ValueGenerator de tipo "{0}" para "{1}"

040002=El repositorio de IDs es invalido
040003=Hemos encontrado un error en la allocación de un block de IDs : {0}
040004=Hemos reservado un bloque de {0} valores
040005=Creando repositorio de IDs en la base de datos ...
040006=El valor de "key-cache-size" ({0}) es invalido
040007=El valor de "sequence" ({0}) es invalido
040008=Hemos encontrado un error en la allocación de IDs : {0}
040009=El generador "{0}" no genera valores numéricos. Por favor llame a "next()" para obtener el valor como un Objeto.

040010=No podíamos crear el "sequence" {0} como los flags de "autoCreate" no estan puestos para permitirlo.
040011=No podíamos crear la tabla para value-generation de "increment"/"table" {0} como los flags de "autoCreate" no estan puestos para permitirlo.

040012=Valor generado para el campo "{0}" con estrategia="{1}" (Generador="{2}") : valor={3}
040013=Identidad generado para el campo {0}, id : {1} es incorrecto
040014=El campo "{0}" ha sido especificado usar un TableGenerator pero no hay uno con nombre "{1}"
040015=El campo "{0}" ha sido especificado usar un SequenceGenerator pero no hay uno con nombre "{1}"

#
# JDOQL
#
042010=JDOQL Single-String de "{0}"
042011=El Query contiene una palabra clave de JDOQL ("{0}") pero no esta en su debido posición. Usted puede poner las palabras claves en una orden definido en la especificación de JDOQL.
042012=JDOQL Single-String Query tiene que empezar con SELECT
042013=JDOQL Single-String Query tiene la palabra clave "{0}" pero es illegal con "{1}" después.
042014=JDOQL Single-String Query tiene la palabra clave "{0}" pero no tiene valor. Debe tener "{1}" despues de "{0}".
042015=JDOQL Single-String expects the keyword "{0}" after the keyword "{1}"
042016=JDOQL Single-String Query tiene clase "{0}" pero no existe. Por favor compruebe que la clase esta en el CLASSPATH
042017=JDOQL Single-String Query tiena una clausula de subquery pero no cierre el parentesis

#
# JPQL
#
043000=JPQL Single-String de "{0}"
043001=El Query de JPQL contiene una palabra clave ("{0}") pero no esta en su debido posición. Usted puede poner las palabras claves en una orden definido en la especificación de JPQL.
043002=JPQL Single-String Query tiene que empezar con SELECT/UPDATE/DELETE/INSERT
043003=JPQL Single-String Query tiene la palabra clave "{0}" pero es illegal con "{1}" después.
043004=JPQL Single-String Query tiene la palabra clave "{0}" pero no tiene valor. Debe tener "{1}" despues de "{0}".
043005=JPQL Single-String expects the keyword "{0}" after the keyword "{1}"
043006=JPQL Single-String Query tiene clase "{0}" pero no existe. Por favor compruebe que la clase esta en el CLASSPATH
043007=JPQL UPDATE/DELETE query no puede tener una clausula de GROUP BY
043008=JPQL UPDATE/DELETE query no puede tener una clausula de HAVING
043009=JPQL UPDATE/DELETE query no puede tener una clausula de ORDER BY
043010=JPQL UPDATE Query no tiene una clausula de UPDATE! Query debe ser como "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"
043011=JPQL UPDATE Query tiene clausula de UPDATE pero no hay SET! Query debe ser como "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"

#
# MetaData
#
044001=Clase "{0}" campo "{1}" : MetaData tiene atributo "{2}" con valor "{3}" pero acepta "{4}"
044002=MetaData extension "{0}" acepta valores de "{1}" pero tiene valor de "{2}"!
044003=Clase "{0}" campo "{1}" : Tiene una collección pero no hay ningun tipo de elemento en el MetaData ni es posible inferirlo por generics, usamos Object
044004=Clase "{0}" campo "{1}" : Tiene un mapa pero no hay ningun tipo de clave-valor en el MetaData ni es posible inferirlos por generics, usamos Object

044005=MetaData Management : Carga de Metadata de los archivos de metadata "{0}" ...
044006=MetaData Management : Carga de Metadata de las clases "{0}" ...
044007=MetaData Management : Carga de Metadata del persistence-unit "{0}" ...
044008=MetaData Management : Carga de Metadata del usuario ...
044009=MetaData Management : Carga de Metadata del jar "{0}" ...
044010=MetaData Management : Carga de Metadata ya ha terminado
044011=No se puede crear Scanner para los metadatos, el tipo de valor no tiene soporte: {0}
044012=No se puede crear una instancia del Scanner: {0}
044013=MetaData Management : Inicialisando con los archivos de MetaData y clases
044014=MetaData Management : Inicialisación con los archivos de MetaData y clases ya ha terminado
044015=El archivo de MetaData "{0}" no contiene MetaData valido
044016=Hemos encontrado errores durante el proceso de leer los archivos de MetaData y clases. Compruebe por favor, las excepciones adjuntados
044017=La clase "{0}" no tiene MetaData o annotaciones.

044018=Populación del MetaData ...
044019=Inicialisación del MetaData ...
044020=Hemos encontrado errores durante la inicialisación de MetaData. Compruebe por favor, las excepciones adjuntados

044021=MetaData Management : Inicialisando con el persistence-unit "{0}"
044022=MetaData Management : Inicialisation con el persistence-unit "{0}" ya ha terminado
044023=Hemos encontrado errores durante el proceso de leer el MetaData del persistence-unit "{0}". Compruebe por favor, las excepciones adjuntados
044024=Hemos encontrado errores durante el proceso de leer el MetaData del jar "{0}". Compruebe por favor, las excepciones adjuntados

044025=Metadata para el campo "{0}" intenta cambiar el primary-key de la definición de metadata "root" (annotaciones o archivo ".jdo" XML). Tiene que especificar primary-key en la definición de metadata "root"

044026=Clase "{0}" descubierto para ser parte del persistence-unit "{1}"; cargandolo
044027=El Persistence-Unit "{0}" contiene una referencia a mapping-file "{1}" pero era imposible leerlo - {2}
044028=El plugin de MetaData handler "{0}" no existe en el CLASSPATH. Por favor compruebe el CLASSPATH y la especificaión de plugin.
044029=Error creando handler del tipo "{0}" para analizar el MetaData : {1}
044030=Analizando el MetaData "{0}" con handler "{1}" (validar="{2}")

044031=¡Intenta de analizar un archivo que era nulo!
044032=Error en abrir el archivo de Meta-Data "{0}"
044033=No puede leer Meta-Data input "{0}"

044034=Clase "{0}" define {1} campos de primary-key pero su superclass tiene {2} campos de primary-key; no se puede agregar mas campos de primary-key!

044036=El tag "{0}" no puede tener el tag padre "{1}" : debe ser {2}
044037=El tag es desconocido : "{0}"
044038=Error en el analizo del archivo "{0}" a la linea {1} : {2} - Por favor compruebe el DTD y la validad de este MetaData.
044039=Error en el analizo del archivo "{0}" a la linea {1}, columna {2} : {3} - Por favor compruebe el DTD y la validad de este MetaData.
044040=Error en el analizo del archivo "{0}" tiene causa {1}
044041=A value is expected in the attribute "{0}" for "{1}" in element "{2}". 

044042=Un error ha ocurrido durante el analisis de <"{0}"> dentro de "{1}" para el URI "{2}"

044043=Registrando la clase "{0}" no tener Meta-Data
044044=Deregistrando la clase "{0}" no tener Meta-Data - ya vamos a añadir el Meta-Data
044045=El archivo "{0}" contiene metadata de tipo "{1}" pero debe contener del tipo "{2}". Vamos a ignorarlo
044046=No hemos encontrado ningun archivo "persistence.xml" en el CLASSPATH. Debes poner esos ficheros en la carpeta META-INF/ de los JARs.
044047=No hemos encontrado el Persistence-Unit "{0}" en los archivos "persistence.xml" disponibles.

044048=No hemos encontrado el MetaData del tipo "{0}" por la clase "{1}"
044049=No encontramos el MetaData del tipo "{0}" por la clase "{1}" en {2}
044050=No encontramos el MetaData por la query {0} en {1}
044051=No encontramos el MetaData por la secuencia {0} en {1}
044052=El MetaData del tipo "{0}" por la clase "{1}" sera {2}
044053=El MetaData por la query {0} sera {1}
044054=El MetaData por la secuencia {0} sera {1}
044055=El analizo del archivo de MetaData {0} falló
044056=El archivo "{0}" va a tener su definición internal de MetaData aumentado con información de ORM MetaData
044057=The package name in empty in MetaData file {1}.
044058=The package {0} has an empty MetaData specified for a class name. Please check the file {1}.
044059=Encontro el Meta-Data de la clase {0} pero la clase no esta analizado! Por favor, debes analizar la clase antes de usar DataNucleus.
044060=Clase "{0}" campo "{1}" : añadiendo el Meta-Data por el campo como no estaba en la definición de Meta-Data.
044061=El elemento de Meta-Data "class" por package {0} necesita un 'name' attributo.

044062=El campo "{0}" esta definido con TypeConverter "{1}" pero no se lo encontramos. Por favor compruebe la definición de TypeConverter y el nombre que ha puesto

044063=Clase "{0}" : esta especificada como persistable pero es Inner y no es estatico. Clases asi no pueden ser persistable.
044064=Clase "{0}" tiene estrategia de heredar como \"superclass-table\" pero no hay ninguna superclase con su propia tabla. Duhhhhhhh

044065=Clase "{0}" : va a usar "application identity", no hay "objectid-class" en la definición, pero hay {1} campos de primary-key. No podemos usar SingleFieldIdentity.
044066=Clase "{0}" : va a usar "application-identity", no hay "objectid-class" y hay un campo de PK , pero el campo es de un tipo invalido {1} por SingleFieldIdentity. Puede usar los tipos short, Short, int, Integer, long, Long, byte, Byte, char, Character, o String.
044067=Clase "{0}" : No hay un class loader especificado por cargar las classes del MetaData de esta clase. Usando el default ClassLoader.
044068=Clase "{0}" : No puede popular la clase como es populado
044069=Clase "{0}" : MetaData no ha sido inicializado por la clase
044070=Clase "{0}" : MetaData no ha sido populado por la clase
044071=Clase "{0}" campo "{1}" : definido en el MetaData, pero este campo no existe en la clase!
044072=Clase "{0}" tiene método {1} definido en el MetaData, pero este método no existe en la clase!
044073=Clase "{0}" tiene propiedad {1} definido en el MetaData, pero el "getter" método no existe en la clase!
044074=Clase "{0}" tiene propiedad {1} definido en el MetaData, pero el "setter" método no existe en la clase!
044075=Clase "{0}" : Populando Meta-Data
044076=Clase "{0}" : Inicializando Meta-Data
044077=Clase "{0}" ha sido definido con el object-id class {1} pero no hay ningun campo como "primary key". Por favor debes anotar con el tag "primary-key" los campos usar como parte de la llave primaria
044078=Class "{0}" has been specified with {1} primary key fields, but this class is using {2} identity and should be application identity.
044079=Clase "{0}" ha sido definido con el object-id class {1}. La clase no existe. Por favor, compruebe la especficación o CLASSPATH.
044080=Clase "{0}" tiene MetaData pero la clase no existe. Por favor compruebe la especificación de CLASSPATH.
044081=Clase "{0}" ha sido definido con un persistence-capable-superclass {1} pero no existe.
044082=Clase "{0}" ha sido definido con un persistence-capable-superclass {1} que no es un superclass de esa clase.
044083=Clase "{0}" ha sido definido con un persistence-capable-superclass {1} que no es Persistence-Capable (no hay Meta-Data).
044087=Clase "{0}" : El persistence-capable-superclass tiene que ser la clase {1}, y no la clase {2}.
044088=Clase "{0}" : El persistence-capable-superclass {1} no se puede encontrar. Por favor compruebe la especificación de CLASSPATH.
044089=Clase "{0}" : DataNucleus ha puesto un valor de persistence-capable-superclass "{1}"; no tenia valor en el MetaData.
044090=Clase "{0}" : ya tiene un campo con el nombre {1}.
044091=Clase "{0}" no tiene un persistence-capable-superclass, pero tiene una superclase "{1}" que ES persistable. Corrigalo por favor.
044092=Clase "{0}" tiene campo {1} con tipo "{2}" pero la clase no existe! Quizas el metadata esta incorrecto?
044093=Clase "{0}" : El tipo de identidad no es lo mismo que el tipo de identidad en la superclase.
044094=Clase "{0}" : La estrategia de Datastore-identity ("{1}") no es la misma que la estrategia de Datastore-Identity en la superclase ("{2}").

044095=Clase "{0}" va a tener su definición internal de MetaData aumentado con información de annotaciones
044096=Clase "{0}" va a tener su definición internal de MetaData aumentado con información de ORM MetaData
044097=Clase "{0}" tiene MetaData con implements {1} pero la clase no existe! Por favor compruebe el CLASSPATH y MetaData.
044098=Clase "{0}" tiene una estrategia de heredar de "{1}" pero soportamos "{2}" solamente.
044099=Clase "{0}" tiene una estrategia de heredar de "superclass-table", pero no superclase existe o no existe con propia tabla
044100=Clase "{0}" tiene una estrategia de heredar de "superclass-table", usando la tabla {1}, pero esa clase no tiene un discriminador.
044101=Clase "{0}" tiene una estrategia de heredar de "superclass-table", usando la tabla {1}, pero esa clase no tiene una columna de discriminador
044102=Clase "{0}" tiene una estrategia de heredar usando la tabla de clase {1} con la columna de discriminador {2}. Esta clase no tiene un valor de discriminador
044103=Clase "{0}" usa la estrategia de discriminación de "value-map" pero no tiene valor. Vamos a usar el nombre de la clase!
044104=Clase "{0}" tiene una estrategia de "{1}" pero DataNucleus no la apoya. Usamos el "default"
044105=Clase "{0}" es abstracto pero tiene un valor de discriminador. No se va a usar el valor nunca!

044106=Clase "{0}" campo "{1}" : No puede popular el campo con un campo nulo.
044107=Clase "{0}" campo "{1}" : No puede popular el campo como ya ha sido populado.
044108=Clase "{0}" campo "{1}" : No puede cambiar el campo como ya ha sido inicializado.
044109=Clase "{0}" campo "{1}" : es definido como {2} con "persistence-modifier={3}" pero tiene "default-fetch-group=true" o "primary-key=true" definido! Deben ser falsos.
044110=Clase "{0}" campo "{1}" : esta declarado con atributo "dependent" pero es una coleccion, array o map y debes declarar dependent dentro de un elemento de "array", "collection" o "map", e.g. como "dependent-element" (para colecciones)
044111=Clase "{0}" campo "{1}" : No podemos persistir el campo porque es de un tipo de array que DataNucleus no apoya. Por favor, debe cambiarlo por una colección.
044112=Clase "{0}" campo "{1}" : ya existe, pero tiene otra definición.
044113=Clase "{0}" campo "{1}" : como de la clase "{2}" pero no hemos encontrado esta clase
044114=Clase "{0}" campo "{1}" : como de la clase "{2}" pero no es una superclase! Usted puede usar solamente los campos de las superclases que son persistable.
044115=Clase "{0}" campo "{1}" : tiene "mapped-by" de "{2}". Este campo no existe en el otro lado de la relación ("{3}")!!
044116=Clase "{0}" campo "{1}" : tiene "implementation-classes" pero la clase de implementación "{2}" no existe!!
044117=Clase "{0}" campo "{1}" : no se puede popular con un valor "{2}" para la propiedad "{3}".

044118=Class "{0}" campo "{1}" : marcado como persistente pero es "final" asi que no se puede persistirlo

044119=Clase "{0}" : Una columna sin campo ha sido especificado sin el nombre. Cualquier columna sin campo tiene que tener un nombre
044120=Clase "{0}" : Una columna "{1}" sin campo ha sido especificado sin el tipo de JDBC. Cualquier columna sin campo tiene que tener un tipo de JDBC

044121=Clase "{0}" campo "{1}" tiene tipo "{2}" pero es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser persistable.
044122=Clase "{0}" campo "{1}" es una collección de elementos de tipo "{2}" pero es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser persistable.
044123=Clase "{0}" campo "{1}" es una mapa con llaves de tipo "{2}" pero la llave es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser persistable.
044124=Clase "{0}" campo "{1}" es una mapa con valores de tipo "{2}" pero el valor es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser persistable.
044125=Clase "{0}" campo "{1}" : añadiendo el Meta-Data por el campo "embedded" en la clase "{2}" como no estaba en la definición de <embedded> Meta-Data.

044126=Clase "{0}" define columna de discriminador, pero hay esa informacion en una superclase! En general ignora esta definición (salvo si ibas a tener una columna de discriminador en muchas tablas por un arbol de heredar).

044127=Clase "{0}" campo "{1}" tiene SERIALIZED y tambien un CONVERTER ("{2}"). No se puede tener los dos a la vez. Ignora el SERIALIZED.

044128=Clase "{0}" esta embedded y tiene miembro "{1}" embedded con el mismo tipo. No se puede embed tipos recursivamente

044129=Clase "{0}" campo "{1}" tiene como "embedded" un objeto de tipo "{2}", pero es "interface" y lo has especificado con un CAMPO "{2}". Debe ser una PROPIEDAD.
044130=Clase "{0}" campo "{1}" tiene <join table="...">. El atributo "table" no tiene sentido cuando <join> esta dentro de <field>. En este caso usted debe poner "table" en <field>.
044131=Clase "{0}" campo "{1}" ha sido definido con <collection> y element-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "implementation-classes" extension de DataNucleus.
044132=Clase "{0}" campo "{1}" ha sido definido con el "collection" MetaData pero no es un campo de Collection.
044133=Clase "{0}" campo "{1}" ha sido definido como Collection pero el tipo de elemento no ha sido definido!
044134=Clase "{0}" campo "{1}" ha sido definido como Collection con elementos de tipo {2}. ¡Este tipo de elemento no existe!
044135=Clase "{0}" campo "{1}" ha sido definido como Collection con elementos de tipo {2}. Este tipo ha sido resuelto a  {3}

044136=Clase "{0}" no tiene una clase de PK pero lo necesita, y utiliza acceso por propiedades asi que no podemos generarla. Por favor, anade una clase de PK

044137=Clase "{0}" campo "{1}" tiene mapped-by de <order> pero el campo ("{2}.{3}") no existe!
044138=Clase "{0}" campo "{1}" tiene ordering con un campo ("{2}.{3}") que no existe!
044139=Clase "{0}" campo "{1}" tiene ordering con una dirección invalida ("{2}"). Debe ser ASC o DESC
044140=Clase "{0}" campo "{1}" ha sido definido con <array> y element-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "implementation-classes" extension de DataNucleus.
044141=Clase "{0}" campo "{1}" ha sido definido con <array> MetaData pero no es un campo de array.
044142=Clase "{0}" campo "{1}" es una matriz de (non-serializado) elementos de tipo "{2}" pero no tiene ningun <join>. Para almacenar una matriz asi necesita una tabla de juntar, o marcarlo como "serialized".
044143=Clase "{0}" campo "{1}" ha sido definido con <map> y key-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "key-implementation-classes" extension de DataNucleus.
044144=Clase "{0}" campo "{1}" ha sido definido con <map> y value-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "value-implementation-classes" extension de DataNucleus.
044145=Clase "{0}" campo "{1}" ha sido definido con "map" MetaData pero no es un campo de Map.
044146=Clase "{0}" campo "{1}" ha sido definido como Map pero el tipo de key no ha sido definido!
044147=Clase "{0}" campo "{1}" ha sido definido como Map con keys del tipo {2}. ¡Este tipo de key no existe!
044148=Clase "{0}" campo "{1}" ha sido definido como Map con keys de tipo {2}. Este tipo de key ha sido resuelto a {3}.
044149=Clase "{0}" campo "{1}" ha sido definido como Map pero el tipo de value no ha sido definido!
044150=Clase "{0}" campo "{1}" ha sido definido como Map con values del tipo {2}. ¡Este tipo de value no existe!
044151=Clase "{0}" campo "{1}" ha sido definido como Map con values del tipo {2}. Este tipo de value ha sido resuelto a {3}.
044152=Clase "{0}" campo "{1}" tiene key-type como "{2}" que es tipo de referencia, y tiene "embedded". DataNucleus no apoya el uso de un tipo de referencia con "embedded".
044153=Clase "{0}" campo "{1}" tiene value-type como "{2}" que es tipo de referencia, y tiene "embedded". DataNucleus no apoya el uso de un tipo de referencia con "embedded".
044154=Clase "{0}" : ¡Query no tiene un nombre ! Por favor, cada Query necesita un nombre.
044155=Clase "{0}" : ¡Sequence no tiene un nombre ! Por favor, cada Sequence necesita un nombre.
044156=La estratagia no esta !
044157=La estratagia no esta !
044158=El factory-class {0} no esta !
044159=El factory-class {0} no hace javax.jdo.IdGenerator !
044160=La especificación del tag de <extension> no esta correcta. El vendor-name ({0}), key ({1}) y value ({2}) deben ser especificados.
044161=Clase "{0}" campo "{0}" : declarado como referencia ("interface" o java.lang.Object) but no hay clases de implementación de "{2}"
044162=Clase "{0}" campo "{1}" : declarado en metadata, pero no hay una superclase persistente con este campo

044163=Clase "{0}" no tiene propia tabla, utiliza application-identity y no tiene campos de primary-key. Marcamos como "persistence instantiable"
044164=Clase "{0}" tiene {1} campos de primary-key pero no tiene "objectidClass" definido. Utilizamos "{2}"

044165=Metadata de 'embedded', pero no soportamos el tipo de padre {0}

044166=Clase "{0}" miembro "{1}" tiene getter con void return! El getter tiene que obedecer las convenciones de Java Bean y devolver el tipo de la propiedad
044167=Clase "{0}" miembro "{1}" tiene getter con tipo de devolver {2} y setter con argumento de tipo {3}. No son consistentes con las convenciones de Java Bean!

044200=Clase "{0}" tiene anotaciones de {1} y vamos a usarlas.
044201=Clase "{0}" tiene anotación "{1}" con propiedad "{2}" pero es invalido. Por favor compruebe la especificación para esta anotación.
044202=Clase "{0}" tiene anotaciones pero no hay ningún AnnotationReader registrado para este tipo de anotaciones. Por favor compruebe el CLASSPATH y las anotaciones para validez.
044203=Clase "{0}" tiene anotación "{1}" que no esta procesado aqui. Si sea un annotacion de extension de DataNucleus, lo procesamos mas tarde.
044204=Clase "{0}" : @Index especificado pero no hay campos/columnas asi que DataNucleus lo ignora
044205=Clase "{0}" : @Unique especificado pero no hay campos/columnas asi que DataNucleus lo ignora
044206=Clase "{0}" : @ForeignKey especificado pero no hay campos/columnas asi que DataNucleus lo ignora
044207=Clase "{0}" : annotation reader con nombre "{1}" no esta. Si fuera un AnnotationReader de usuario, por favor compruebe su especificacion, o si no, reportalo a los programadores
044208=No se puede encontrar el handler para la anotacion de clase "{0}". Por favor reportalo!
044209=No se puede encontrar el handler para la anotacion de campo "{0}". Por favor reportalo!

044211=Clase "{0}" campo "{1}" tiene anotación "{2}" que no esta procesado aqui. Si sea un annotacion de extension de DataNucleus, lo procesamos mas tarde.
044212=Clase "{0}" campo "{1}" : es contenedor, pero no hay soporte para el tipo "{2}". Por favoir compruebe la definición, y/o que tienes los plugins necesarios en el CLASSPATH.

044213=Valor invalido para una extension de metadata: "{0}" => "{1}"

#
# Datastore Connection
#
046000=No es valido usar el método "{0}" de una connección obtenida del PersistenceManager.
046001=Connection ya no es disponible

#
# Query Result
#
052600=El resultado del Query ya esta cerrado
052601=Ha encontrado un error leyendo el ResultSet : {0}
052602=No hay más elementos en el resultado del Query
052603=No puede cambiar el ResultSet del Query
052604=No apoyamos esta operación en el resultado de un Query
052605=Cerrar el resultado del Query da un error : {0}
052606=Leyendo los resultados del query "{0}" como la conneccion va a cerrar o cometer
